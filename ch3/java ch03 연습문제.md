#[3-1]
상세 코드는 ch03폴더에 자바코드 참조<br>
결과값: 6, true, 13 ,5, false, 2, 5, 66, B, B, C<br>
1) `1 + x << 33`<br>
x에 1을 더한 3의 값의 2진수가 쉬프트 연산자에 의해 자리이동한다.<br>
이는 쉬프트 연산자가 산술 연산자보다 우선순위가 낮기 때문이다. <br>
이 때 변수 x는 int형 변수이므로 2진수일시의 자릿수는 32bite이다.<br>
고로 32자리 이동시에는 제자리로 돌아오기에,<br>
33자리 이동은 사실상 한 자리만 이동하는 게 된다.<br>
쉬프트 연산자로 이동하면 값은 그 2의 n승을 곱하는 것이 된다.<br>
즉, 3 << 1은 3 x 2가 되어 6이 나온다.<br>
<br>
2) `y >= 5 || x < 0 && x > 2`<br>
논리 연산자 중에서는 &&가 ||보다 우선순위가 높아 먼저 처리된다.<br>
x는 2이며, &&은 양변이 모두 참이어야 true가 나오므로 위 식의 && 값은 false가 된다.<br>
||는 한쪽이 참이라도 결과가 true가 나오며, y=5라 왼쪽 항이 true이므로,<br>
결과적으로 최종값은 true가 된다.<br>
<br>
3) `y += 10 - x++`<br>
+=는 복합 대입 연산자로 위 식은 `y = y + (10 - x++)`와 같다.<br>
주목해야 할 것은 x의 값을 증가시키는 ++, 증가 연산자가 붙어있다는 것이다.<br>
만약 x의 앞에 붙은 전위형이라면 값이 참조되기 전에 값이 증가하나, 위 식에서는 후위형이다.<br>
고로 x의 값이 증가되기 전에 식이 처리되어 y는 대입 연산자에 의해 13으로 저장되고,<br>
x는 후에 값이 1 증가하여 3으로 저장한다.<br>
대부분의 연산자는 피연산자의 값으로 연산만 하나,<br>
대입 연산자와 증감 연산자는 직접 피연산자의 값을 변경한다.<br>
<br>
4) 위에서 x가 3으로 저장되었으므로 여기에 값 2를 더해 5가 출력되어,<br>
대입 연산자로 인해 x=5로 저장된다.<br>
<br>
5)`!('A' <= c && c <= 'Z')` <br>
논리 부정 연산자 !는 피연산자의 결과값을 반대로 바꾸는 것이다.<br>
괄호 안에 식은 변수인 c가 'A'이므로 true이다. 여기에 !를 썼으므로 값은 false가 된다.<br>
<br>
6)이항 연산자 중 피연산자가 int형보다 낮으면 자동 형변환으로 int형으로 바뀐다.<br>
이로 인해 'C'와 'A' 모두 해당하는 유니코드 값으로 계산되어 답은 2다.<br>
<br>
7, 8) 위와 같은 논리.<br>
단, 대입 연산자인 =를 안 썼기에 값 자체는 변화하지 않고 연산만 한 것임을 잊지 않는다.<br>
<br>
9) 증가 연산자를 전위형으로 썼으므로 값이 1 증가하여 B로 출력된다.<br>
<br>
10) 9번과 반대로 후위형으로 썼으므로 우선적으로 값이 변하기 전 B로 출력된 뒤, C로 저장된다.<br>
<br>
11) 10번의 B가 출력된 후, 변수 C가 C로 저장되었음을 확인할 수 있다.

# [3-2]
상세 코드는 ch03폴더에 자바코드 참조<br>
여기서 문제의 답을 코드로 적을 것을 요구하고 있다.<br>
간단하게 변수값 13을 입력할 수도 있으나, 코드 작성을 요구하므로 이에 맞추어 짜도록 한다.<br>
앞에 사과갯수(numOfApples)와 상자 수용값(sizeBucket)이 따로 정리되어 있으므로 이를 이용한다.<br>
필요한 상자값을 요구하므로 간단하게 사과갯수를 수용값으로 나누면 된다.<br>
즉, `numOfApples/sizeBucket`으로 표현한다.<br>
문제는 나머지가 발생한다는 점이며, 실제로 필요한 상자 갯수는 13개라는 점이다.<br>
간단하게 +1 하면 될 수도 있으나, 여기서는 실제로 배운 나머지 연산자와 삼항 연산자를 활용해본다.<br>
`numOfApples%sizeBucket > 0 ? 1 : 0` 나머지 연산자를 사용하여 나머지가 0보다 클 시,<br>
true가 되므로 1, false라면 0이 되게 하는 식이다. 이를 앞서 표현한 코드와 산술 연산자로 잇는다.<br>
`numOfApples/sizeBucket+(numOfApples%sizeBucket > 0 ? 1 : 0)`가 답이 된다.

# [3-3]
상세 코드는 ch03폴더에 자바코드 참조<br>
삼항 연산자에 삼항 연산자를 포함시키면 총 3가지 경우를 표현 가능하다.<br>
우선 변수 num이 0보다 큰 경우와 아닌 경우로 나누고,<br>
거기에 ()를 쳐서 새로운 삼항 연산자를 포함시킨다. 여기서 각각 0과 음수의 경우가 나오도록 식을 짠다.<br>
내 경우에는 이곳에서 `x==0 ? "0" : "음수"` 를 사용했으나, 답안에서는 `x < 0 ? "음수" : "0"`로 되어있다.

# [3-4]
상세 코드는 ch03폴더에 자바코드 참조<br>
456에서 백의 자리 미만을 전부 버리는 코드를 묻고 있다.<br>
나는 이 문제를 `100*(int)(num/100.0)`로 작성했었다.<br>
실수형에서 정수형으로 바뀔 시 소수점 이하가 전부 버려진다는 걸 활용하기 위해서다.<br>
이를 위해 456에서 100.0(자동 형변환으로 실수형 변경)으로 나누어 4.56으로 만든 뒤,<br>
(int)로 형변환시켜 4로 만든다.<br>
여기에 다시 100을 곱했다.<br>
하지만 번거롭게 이럴 필요가 없이 애초에 정수형으로 나눗셈 연산자를 쓰면 소수값은 전부 버려지므로,<br>
간단하게 num에서 100을 나눈 뒤 곱하면 더욱 쉽게 같은 값을 구할 수 있다.

# [3-5]
상세 코드는 ch03폴더에 자바코드 참조<br>
이 문제에서 중요한 것은 일의 자리만 변경하는 것이다.<br>
333이면 331, 777이면 771과 같은 결과만 나와야 하므로 단순히 -2를 해선 안 된다고 생각했다.<br>
결국 일의 자리만 바꾸면 되는 것이므로 333을 10으로 나누어 33으로 만든 뒤,<br>
여기에 다시 10을 곱해 330으로 만들어 1을 더하는 식이다.

# [3-6]
상세 코드는 ch03폴더에 자바코드 참조<br>
변수값에서 크면서 가장 가까운 10의 배수로 바꾼 뒤, 변수를 뺀 나머지를 구하는 식을 묻고 있다.<br>
나머지 연산자를 사용한다 했을 때, 나는 가장 가까운 큰 배수로 바꾸는 방법을 생각했고,<br>
5번 문제의 답을 활용해 `num/10*10+10`로 식을 짰다.<br>
일의 자리를 버림과 동시에 10을 더함으로서 10의 배수를 만드는 식이다.<br>
여기에 변수 num을 피연산자로 삼아 나머지 연산자를 사용하면 값이 구해진다.

# [3-7]
상세 코드는 ch03폴더에 자바코드 참조<br>
문제에서 요구하는 해답에 맞게 식을 짜냈으나 답안의 답과 비교하면 군더더기가 조금 많다.<br>
내가 짜낸 답은 이렇다. `((int)(5/9f * (fahrenheit-32)*100)+1)/100.0f;`<br>
섭씨 식에서 100을 곱한 뒤 괄호로 감싸고, 그대로 int형으로 형변환시켜 +1한다.<br>
3번째 소수점 자리에서 반올림이므로 둘째 자리의 값을 1 올리는 것이다.<br>
이를 다시 100으로 나누면 문제에서 요구하는 답이 된다.<br>

두 가지 유의할 점은 섭씨 식에 있는 5/9의 경우, 둘 다 정수이면 소수점이 버려진다.<br>
이로 인해 올바른 값이 안 나오고 0이 되어버리므로 한쪽에 접미사 f를 붙여 실수로 바꿀 필요가 있다.<br>
같은 논리로 마지막에 100으로 나눌 시, 나누는 값인 100은 실수형인 100.0 혹은 100f로 한다.

# [3-8]
1) `byte c = a+b;`<br>
산술변환에 의해 byte, short, char은 자동으로 int형으로 바뀌어 저장된다.<br>
고로 우변값이 int형이기에 byte로 저장이 불가능하며 (byte)로 형변환시켜야 한다.<br>
<br>
2) `ch = ch+2;`<br>
1번과 같은 이유. <char>로 형변환시킨다.<br>
<br>
3) `float f = 3/2;`<br>
피연산자가 모두 정수라 결과값이 정수로 저장되어 소수점 이하가 전부 사라진다.<br>
문제에서 요구하는 건 소수점 이하도 포함되기에 둘 중 하나에 접미사 f를 붙여 실수로 바꾼다.<br>
<br>
4) `long l = 3000*3000*3000;`<br>
결과값이 정수로 저장되고 그 범위가 int형을 넘어 오버플로우가 발생한다.<br>
피연산자에 접미사 L을 붙여 long형으로 바꾼다.<br>
<br>
5) `	float f2 = 0.1f; double d = 0.1;	boolean result = d==f2;`<br>
실수형에서 float와 double은 정밀도가 달라 오차가 발생한다.<br>
float값이 저장된 시점에서 값이 다르므로 나중에 (double)로 형변환시키는 건 의미가 없다.<br>
double 변수에 처음부터 float값으로 저장하여 true로 바꾼다.<br>
또는 result=부분에서 (float)로 형변환시킨다.

# [3-9]
영문자 또는 숫자일 때 true값이므로 논리 연산자 ||를 사용한다.<br>
이 때, 영문자의 범위와 숫자의 범위를 ()로 나누며 각각 논리 연산자 &&를 사용한다.<br>

# [3-10]
입력값이 대문자일 때 소문자로 변형시키는 코드이므로, 조건문을 사용한다.<br>
그 중에서도 문제는 삼항 연산자를 제시하고 있으므로 이에 맞추어 적용한다.<br>
false일시 입력값이 그대로 나오게 되어있으므로, 조건은 대문자의 범위를 지정하면 된다.<br>
`'A'<=ch&&ch<='Z'`. 소문자와 대문자의 차이는 32이므로 참일시 ch+32를 행한다.<br>
이 때 산술변환에 의해 값이 int가 되므로 (char)로 형변환시킨다.
